All backtracking problems will follow the same pattern/structure.
some sort of recursive function, a loop within the function, and a appending and popping (backtracking part) of a list/object

syntax:
    def backtracking(point):
        if base_case_condition:
            res.append(temp[:])  #have to do temp[:] because just temp is a reference so when popping the appended temp also changes
            return
        for each possible choice:
            make the choice #(either append or add)
            backtrack(next_point) #recursive calls
            undo the choice #popping or removing previously added element

A majority of backtracking problems are the ones where they ask for all possible combinations/permutations of somthing. If you see a problem
asking for exploring all choices or to provide all solutions it is most likely a backtracking problem

If elements cant be reused use backtrack(i + 1) (only elements after i will be used in recursive calls)
If elements can be reused use backtrack(i) (will always check all elements) (if you have this you need a basecase that returns/breaks the recursion)

You should always pass the temp list (if it has a total pass it too) in the reducsive function

ASK YOURSELF: 
    1. Can elements be reused? → If yes, call backtrack(i) (not i + 1)
    2. Do combinations have to be unique? → Use start index to avoid revisiting earlier elements
    3. Is the target an exact sum? → Track total or sum(temp) and prune if > target
    4. Are there duplicates in input? → You might need sorting + skipping logic (not needed in this specific problem)